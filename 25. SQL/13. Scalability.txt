TOPIC: DATABASE SCALABILITY

1. **Definition of Scalability**
   - Scalability refers to a **database’s ability to handle increasing amounts of data** or **growing numbers of operations** (queries, writes, users, etc.).
   - As data and user requests grow, the system must **continue performing efficiently** without crashing or slowing down.

2. **Why Scalability is Needed**
   - Databases reach limits in:
     - **Storage capacity** → can’t hold more data.
     - **Processing power** → can’t handle more queries/requests per second.
   - To solve this, we need to **scale** the database to support growth.

3. **Two Types of Scalability**
   - There are two main strategies:
     1. **Vertical Scalability (Scaling Up)**
     2. **Horizontal Scalability (Scaling Out)**

---

### 4. **Vertical Scalability (Scaling Up)**
   - Means **adding more power to a single machine**.
   - Example upgrades:
     - Add more **disk space** (for more storage)
     - Add more **RAM** (for faster access)
     - Add a more **powerful CPU**
   - Essentially, make one server **bigger and stronger**.

   **Advantages:**
   - Simple to implement.
   - No need to modify application logic or database structure.
   - Works well for **relational databases** (e.g., MySQL, PostgreSQL).

   **Disadvantages:**
   - **Expensive:** High-end hardware costs a lot.
   - **Physical limits:** A single machine can only be upgraded so far.
   - **Single point of failure:** If that machine goes down, the whole database fails.

   **Use Case:**
   - Older relational databases often relied on vertical scaling since they were optimized for single-machine performance.

---

### 5. **Horizontal Scalability (Scaling Out)**
   - Means **adding more machines (servers)** instead of upgrading one.
   - Multiple databases (nodes) **work together as one system**.

   **Example:**
   - Instead of one big database, use **three smaller databases** that share and sync data.

   **Advantages:**
   - Cheaper — can use many low-cost machines.
   - Virtually **unlimited growth** — just keep adding more machines.
   - Provides **fault tolerance** — if one node fails, others can still serve data.

   **Disadvantages:**
   - **Complexity increases** as you add machines.
   - Data must be **synchronized** between servers.
   - May lead to **data inconsistency** (e.g., one node updates before others).
   - Harder to manage relationships and transactions across nodes.

---

### 6. **Why NoSQL Became Popular**
   - Around the 2000s, **MongoDB** and other NoSQL systems emerged.
   - NoSQL databases like MongoDB were designed for **horizontal scalability**.
   - They can easily spread data across multiple servers.
   - In contrast, **relational databases** had trouble scaling horizontally due to complex relationships and constraints.

   **Example:**
   - MongoDB can store simple JSON-like documents across multiple machines.
   - Each node can handle different parts of the dataset efficiently.

---

### 7. **Modern Relational Databases**
   - Today, even relational databases (e.g., PostgreSQL, MySQL clusters) can achieve horizontal scaling using **replication**, **sharding**, and **load balancing**.
   - However, it remains **more complex** to implement than in NoSQL systems.

---

### 8. **Challenges in Horizontal Scaling**
   - As the number of nodes increases:
     - Communication between nodes becomes **slower and more complex**.
     - Maintaining **data consistency** becomes harder.
     - Updates must be **synchronized** across all nodes.
     - Risk of **latency and stale data** increases.

   **Example Problem:**
   - One server updates a record → another server still holds old data for a few milliseconds → temporary inconsistency.

---

### 9. **Summary Comparison Table**

| Aspect | Vertical Scaling | Horizontal Scaling |
|--------|------------------|--------------------|
| Strategy | Add more power to one machine | Add more machines |
| Cost | Expensive (hardware) | Cheaper (many small servers) |
| Complexity | Simple | Complex |
| Limitations | Hardware limits | Synchronization issues |
| Downtime | Possible | Less (redundant nodes) |
| Used by | Traditional SQL (PostgreSQL, MySQL) | NoSQL (MongoDB, Cassandra) |

---

### 10. **Conclusion**
   - Two main scalability options:
     1. **Vertical Scaling** – scale by upgrading one machine.
     2. **Horizontal Scaling** – scale by adding more machines.
   - Modern systems often **combine both** strategies.
   - **NoSQL** systems popularized horizontal scaling due to flexibility.
   - However, **relational databases** are catching up with newer features like **clustering and sharding**.

→ Next topic: **Sharding**, which explains how databases split data across multiple servers in a horizontally scaled system.
